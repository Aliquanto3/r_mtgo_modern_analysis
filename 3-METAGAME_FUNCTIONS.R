################################################################################
#LIBRARIES
# install.packages("ggplot2")
# install.packages("dplyr")
# install.packages("ggrepel")
# install.packages("jsonlite")
# install.packages("tidyverse")
# install.packages("data.table")
# install.packages("purrr")
# install.packages("jsonify")
# install.packages("plyr")
# install.packages("FactoMineR")
# install.packages("factoextra")
# install.packages("corrplot")
# install.packages("ggpubr")
# install.packages("expm")
# install.packages("matrixStats")
# install.packages('gganimate')
# install.packages("gifski")
# install.packages("raster")
# install.packages("conflicted")
# install.packages("xlsx")
# install.packages("ClustMAPDP")
# install.packages("plot.matrix")
# install.packages("ggthemes")
# install.packages("ggtext")
library(ggplot2)
library(dplyr)
library(ggrepel)
library(jsonlite)
library(tidyverse)
library(data.table)
library(purrr)
library(jsonify)
library(plyr)
library(FactoMineR)
library(factoextra)
library(corrplot)
library(ggpubr)
library(expm)
library(matrixStats)
library(gganimate)
library(gifski)
library(raster)
library(conflicted)
library(viridis) 
library(paletteer)
library(plot.matrix)
library(ggthemes)
library(ggtext)
#library(ClustMAPDP)

Sys.setenv(JAVA_HOME='C:\\Program Files (x86)\\Java\\jre1.8.0_181') 
library(xlsx)

#IF YOU WANT TO REMOVE THE conflicted PACKAGE TO USE "View(df)"
#unloadNamespace("conflicted")

conflict_prefer("select", "dplyr")
conflict_prefer("arrange", "dplyr")
conflict_prefer("View", "utils")

################################################################################

#' List of all different archetypes in the data
#'
#' @param df the dataframe generated by 
#' generate_df(EventType, MTGFormat, RawFile, Date.autoupdate)
#'
#' @return a named vector with the list of archetypes in the parameter data
#' @export
#'
#' @examples
generate_archetype_list = function(df){
  #CREATE A DATAFRAME CONTAINING THE LIST OF ARCHETYPES
  arch_list=data.frame(unique(df$Archetype$Archetype))
  names(arch_list)[1] = c("Archetype")
  return(arch_list)
}

#' Return metagame presence of each archetype
#'
#' @param df the dataframe generated by 
#' generate_df(EventType, MTGFormat, RawFile, Date.autoupdate) 
#' @param graph_share the % of presence under which archetypes are regrouped in
#' an "Other" category
#' @param presence the definition of metagame presence (aka share) to use. 
#' It can be:
#' - "Copies": the number of lines in the dataframe dedicated to that archetype
#' - "Players": the number of different players piloting that archetype
#' - "Matches": the number of matches played by the archetype
#'
#' @return
#' @export
#'
#' @examples
generate_metagame_data = function(df,graph_share,presence){
  
  arch_list=generate_archetype_list(df)
  
  #ADD THE PRESENCE OF EACH ARCHETYPE IN THE DATA
  arch_list$Presence=rep(0,length(arch_list$Archetype))
  
  for (i in 1:length(arch_list$Presence)){
    arch_id=which(df$Archetype$Archetype==arch_list$Archetype[i])
    if (presence=="Copies"){
      #NUMBER OF COPIES
      arch_list$Presence[i]=length(arch_id)
    }else if (presence=="Players"){
      #NUMBER OF PLAYERS
      arch_list$Presence[i]=length(unique(df[arch_id,]$Player))
    }else if (presence=="Matches"){
      #NUMBER OF ROUNDS PLAYED
      arch_list$Presence[i]=sum(df[arch_id,]$NRounds,df[arch_id,]$T8Matches)
    }
  }
  
  #FOR EASIER READING OF THE GRAPHS, AGGREGATE ALL THE ARCHETYPES ACCOUNTING FOR 
  #LESS THAN graph_share% OF THE DATA
  graph_perc=graph_share/100*sum(arch_list$Presence)
  arch_list_vis=arch_list[arch_list$Presence >= graph_perc, ]
  #arch_list_vis=arch_list_vis[order(arch_list_vis$Archetype, decreasing = TRUE),]
  arch_list_vis=arrange(arch_list_vis,desc(Presence))
  
  #ADD AN "OTHER" CATEGORY CONTAINING THE SUM OF COPIES OF ARCHETYPES UNDER X%
  sum_others=sum(arch_list[arch_list$Presence < graph_perc, ]$Presence)
  otherName=paste("Other (each <",graph_share,"%)",sep="")
  arch_list_vis=rbind(arch_list_vis,c(otherName, sum_others))
  #arch_list_vis=arch_list_vis[order(arch_list_vis$Archetype),]
  
  arch_list_vis$Presence=as.numeric(arch_list_vis$Presence)
  arch_list_vis$Share=as.numeric(format(round(arch_list_vis$Presence/
                                                sum(arch_list_vis$Presence)*100,
                                              1), nsmall = 1))
  
  arch_list_vis$Archetype = reorder(arch_list_vis$Archetype, 
                                     as.numeric(arch_list_vis$Presence))
  arch_list_vis$Archetype = relevel(arch_list_vis$Archetype, otherName)
  
  arch_list_vis$Archetype=fct_rev(arch_list_vis$Archetype)
  
  return(arch_list_vis)
}

#COMPUTES A NAME FOR THE HISTOGRAM AND THE PIE CHART
#presence CAN BE EITHER "Copies", "Players" or "Matches"
generate_metagame_graph_title = function(presence,beginning,end,EventType){
  MetaGraphTitle=paste("Proportion of", Classification,"archetypes in MTGO", 
                       EventType,"between\n", beginning, "and", end,
                       "based on number of", presence,sep = " ")
  return(MetaGraphTitle)
}

#GENERATE A PIE CHART BASED ON DATA IN DF
#presence CAN BE EITHER "Copies", "Players" or "Matches"
metagame_pie_chart = function(df,PieShare,presence,beginning,end,EventType){
  
  #CHANGE THE NUMBER FOR THE PROPORTION OF THE "OTHERS" CATEGORY HERE
  df_gen=generate_metagame_data(df,PieShare,presence)
  
  ggplot(df_gen, aes(x="", -Share, fill = Archetype)) + 
    geom_bar(width = 1, size = 1, color = "white", stat = "identity") + 
    coord_polar("y", start=0) + 
    geom_text(aes(label = paste0(Share, "%"), x = 1.3), 
              position = position_stack(vjust = 0.5), size = 3) +
    labs(x = NULL, y = NULL, fill = NULL, subtitle = "by Anaël Yahi",
         title = generate_metagame_graph_title(
           presence,beginning,end,EventType)) + 
    guides(color = FALSE, size = FALSE) +
    scale_color_gradient(low="red", high="blue") +
    theme_classic() +
    theme(axis.line = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          plot.title = element_text(hjust = 0.5, color = "#111111",size = 20),
          plot.subtitle = element_text(hjust = 0.5,size = 18),
          legend.text = element_text(size = 17))
  
}

#GENERATE A BOX PLOT BASED ON DATA IN DF
#presence CAN BE EITHER "Copies", "Players" or "Matches"
metagame_box_plot = function(df,presence,beginning,end,EventType,histShare){
  
  #GET THE DATA FOR ALL ARCHETYPES HAVING A META Share ABOVE HistShare
  df_gen=generate_metagame_data(df,histShare,presence)
  
  #GENERATE A TITLE FOR THE BOXPLOT
  boxplot_title=paste(generate_metagame_graph_title(
    presence,beginning,end,EventType),"-",
    df_gen[grep("Other",df_gen$Archetype),]$Archetype, sep=" ")
  
  #THIS GRAPH DOESN'T DISPLAY THE "Other" CATEGORY
  df_gen=df_gen[!grepl("Other",df_gen$Archetype),]
  
  #REORDER ARCHETYPES BY ASCENDING PRESENCE
  df_gen$Archetype = reorder(df_gen$Archetype, as.numeric(df_gen$Presence))
  
  #plot is much clearer
  ggplot(df_gen, aes(x=Archetype, y=as.numeric(Share), fill=Archetype)) + 
    geom_bar(stat="identity") + theme_minimal() + guides( fill = FALSE) +
    labs(x = NULL, y = "Presence (%)", fill = NULL, 
         title = boxplot_title, subtitle = "by Anaël Yahi") + 
    scale_color_gradient(low="blue", high="red") +
    #scale_x_discrete(guide = guide_axis(n.dodge=2)) + 
    theme(axis.text.x  = element_text(size=12)) + coord_flip()
}

#LIST ALL THE DIFFERENT PLAYERS IN THE DATA
generate_player_list = function(df){
  #CREATE A DATAFRAME CONTAINING THE LIST OF ARCHETYPES
  play_list=data.frame(unique(df$Player))
  names(play_list)[1] = c("Players")
  return(play_list)
}

#FILL IN METRIC POINTS IN A PLAYER DATA FRAME
metric_points_players = function(df){
  #GET THE LIST OF THE DIFFERENT PLAYERS IN THE DATA
  metric_df_players=generate_player_list(df)
  
  metric_df_players$NAppearances=rep(0,nrow(metric_df_players))
  metric_df_players$TotalMatches=rep(0,nrow(metric_df_players))
  metric_df_players$WinrateAverage=rep(0,nrow(metric_df_players))
  metric_df_players$Winrate95Min=rep(0,nrow(metric_df_players))
  metric_df_players$Winrate95Max=rep(0,nrow(metric_df_players))
  metric_df_players$TotalPoints=rep(0,nrow(metric_df_players))
  metric_df_players$ArchetypeNames=rep(0,nrow(metric_df_players))
  metric_df_players$ArchetypeCounts=rep(0,nrow(metric_df_players))
  metric_df_players$URL=rep(0,nrow(metric_df_players))
  for (i in 1:nrow(metric_df_players)){
    #POSITION OF THE CORRESPONDING EXACT OR SUPER ARCHETYPE IN THE DATA
    play_identification=which(df$Player==metric_df_players$Players[i])
    df2=df[play_identification,]
    #NUMBER OF APPEARANCES IN THE DATA OF THE CORRESPONDING ARCHETYPE
    metric_df_players$NAppearances[i]=length(play_identification)
    #LIST OF DIFFERENT ARCHETYPES THAT PLAYER PLAYED
    metric_df_players$ArchetypeNames[i]=list(unique(df2$Archetype$Archetype))
    #paste(unique(df2$Archetype$Archetype),collapse=",")
    arch_count=c()
    for(j in 1:length(metric_df_players$ArchetypeNames[[i]])){
      arch_count[j]=length(df2[df2$Archetype$Archetype==metric_df_players$
                                 ArchetypeNames[[i]][[j]],]$AnchorUri)
    }
    metric_df_players$ArchetypeCounts[i]=list(arch_count)
    
    metric_df_players$URL[i]=list(unique(df2$AnchorUri))
    #paste(df2$AnchorUri,collapse=",")
    
    #NUMBER OF MATCHES PLAYED BY THAT ARCHETYPE IN THE DATA
    metric_df_players$TotalMatches[i]=sum(df2$NRounds,
                                          df2$T8Matches)
    #NUMBER OF WINS OF THAT ARCHETYPE
    total_wins_arch=sum(df2$NWins + df2$T8Points/3)
    #NUMBER OF MATCHES OF THAT ARCHETYPE
    total_matches_arch=sum(df2$NRounds + df2$T8Matches)
    metric_df_players$TotalPoints[i]=total_wins_arch*3
    
    #95% CONFIDENCE INTERVALS OF THE WINRATE
    #EFFECTIVE WINRATE IN THE DATA
    metric_df_players$WinrateAverage[i]=binom.test(total_wins_arch, total_matches_arch, 
                                                   p=0.5,alternative="two.sided", 
                                                   conf.level=0.95)$estimate
    #LOWER BOUND OF THE MEASURED WINRATE             
    metric_df_players$Winrate95Min[i]=binom.test(total_wins_arch, total_matches_arch, 
                                                 p=0.5,alternative="two.sided", 
                                                 conf.level=0.95)$conf.int[1]
    #UPPER BOUND OF THE MEASURED WINRATE 
    metric_df_players$Winrate95Max[i]=binom.test(total_wins_arch, total_matches_arch, 
                                                 p=0.5,alternative="two.sided", 
                                                 conf.level=0.95)$conf.int[2]
  }
  metric_df_players=arrange(metric_df_players,desc(TotalPoints))
  
  return(metric_df_players)
}

#FILL IN METRIC POINTS IN AN ARCHETYPES DATA FRAME
metric_points_archetypes = function(df){
  #GET THE LIST OF THE DIFFERENT ARCHETYPES IN THE DATA
  metric_df=generate_archetype_list(df)
  players_df=metric_points_players(df)
  
  metric_df$NCopies=rep(0,length(metric_df$Archetype))
  metric_df$NPlayers=rep(0,length(metric_df$Archetype))
  metric_df$TotalMatches=rep(0,length(metric_df$Archetype))
  metric_df$WinrateAverage=rep(0,length(metric_df$Archetype))
  metric_df$Winrate95Min=rep(0,length(metric_df$Archetype))
  metric_df$Winrate95Max=rep(0,length(metric_df$Archetype))
  metric_df$MatchesPerPlayer=rep(0,length(metric_df$Archetype))
  metric_df$WinrateArchetypeOutPlayers=rep(0,length(metric_df$Archetype))
  
  for (i in 1:length(metric_df$Archetype)){
    #POSITION OF THE CORRESPONDING EXACT OR SUPER ARCHETYPE IN THE DATA
    arch_identification=which(df$Archetype$Archetype==metric_df$Archetype[i])
    dfArchID = df[arch_identification,]
    #NUMBER OF APPEARANCES IN THE DATA OF THE CORRESPONDING ARCHETYPE
    metric_df$NCopies[i]=length(arch_identification)
    #NUMBER OF DIFFERENT PLAYERS PLAYING THAT DECK
    metric_df$NPlayers[i]=length(unique(dfArchID$Player))
    #NUMBER OF MATCHES PLAYED BY THAT ARCHETYPE IN THE DATA
    metric_df$TotalMatches[i]=sum(dfArchID$NRounds, dfArchID$T8Matches)
    #NUMBER OF MATCHES PER PLAYER - THE HIGHER, THE MORE A PLAYER wiTH THAT DECK
    #APPEARED IN THE RESULTS
    metric_df$MatchesPerPlayer[i]=metric_df$TotalMatches[i]/metric_df$NPlayers[i]
    
    #NUMBER OF WINS OF THAT ARCHETYPE
    total_wins_arch=sum(dfArchID$NWins + dfArchID$T8Points/3)
    #NUMBER OF MATCHES OF THAT ARCHETYPE - not accounting for draws
    total_matches_arch=sum(dfArchID$NRounds - dfArchID$NDraws + dfArchID$T8Matches)
    
    #95% CONFIDENCE INTERVALS OF THE WINRATE
    #EFFECTIVE WINRATE IN THE DATA
    metric_df$WinrateAverage[i]=binom.test(total_wins_arch, total_matches_arch, 
                                            p=0.5,alternative="two.sided", 
                                            conf.level=0.95)$estimate
    #LOWER BOUND OF THE "TRUE" WINRATE             
    metric_df$Winrate95Min[i]=binom.test(total_wins_arch, total_matches_arch, 
                                           p=0.5,alternative="two.sided", 
                                           conf.level=0.95)$conf.int[1]
    #UPPER BOUND OF THE "TRUE" WINRATE 
    metric_df$Winrate95Max[i]=binom.test(total_wins_arch, total_matches_arch, 
                                           p=0.5,alternative="two.sided", 
                                           conf.level=0.95)$conf.int[2]
    
    #WINRATE OF THAT ARCHETYPE DIVIDED BY THE AVERAGE WINRATE OF ITS PILOTS
    metric_df$WinrateArchetypeOutPlayers[i]=metric_df$WinrateAverage[i]/
      mean(players_df[grep(metric_df$Archetype[i],
                           players_df$ArchetypeNames),]$WinrateAverage)
  }
  
  return(metric_df)
}

#PROVIDE A GRAPH FOR A METRIC DATAFRAME DISPLAYING WINRATES DEPENDING ON
#PRESENCE, WHICH IS HIGHLIGHTED BY THE DIAMETERS OF ANOTHER TYPE OF PRESENCE
#presence AND diameters CAN BE EITHER "Copies", "Players" or "Matches"
#tiers CAN BE EITHER "Win+Pres","Pres M+SD" or "Pres %"
#isLog is a boolean
#only_best is a boolean
metric_graph = function(metric_df,presence,diameters,diam_ratio,beginning,end,
                        tiers,isLog,only_best,EventType) {
  if(only_best){
    metric_df=metric_df[metric_df$TotalMatches>mean(metric_df$TotalMatches),]
  }
  
  #COMPUTES THE PARAMETERS OF THE LINES TO APPEAR ON THE GRAPH
  if (presence=="Copies"){
    coeffdir=-max(metric_df$WinrateAverage)/max(metric_df$NCopies/
                                                  sum(metric_df$NCopies)*100)
  }else if (presence=="Players"){
    coeffdir=-max(metric_df$WinrateAverage)/max(metric_df$NPlayers/
                                                  sum(metric_df$NPlayers)*100)
  }else if (presence=="Matches"){
    coeffdir=-max(metric_df$WinrateAverage)/max(metric_df$TotalMatches/
                                                  sum(metric_df$TotalMatches)*100)
  }
  average=mean(metric_df$WinrateAverage)
  sdeviation=sd(metric_df$WinrateAverage)
  
  #GENERATES THE LABELS
  if (presence=="Copies"){
    x_label="Total number of copies of each archetype (%)"
  }else if (presence=="Players"){
    x_label="Total number of different players for each archetype (%)"
  }else if (presence=="Matches"){
    x_label="Total number of matches played by each archetype (%)"
  }
  y_label="Average winrate of each archetype (%)"
  graph_title=paste("Winrates depending on presence:", Classification,"archetypes ", 
                    "between", beginning, "and", end, "in MTGO", EventType,sep = " ")
  graph_subtitle=paste("Circle diameters depending on",diameters,"\nby Anaël Yahi",sep=" ")
  if(tiers=="Win+Pres"){
    graph_subtitle=paste("Separated by mean +/- n standard deviations (n={0,1,2,3}) 
Circle diameters depending on",diameters,"\nby Anaël Yahi",sep=" ")
  }
  
  #GENERATES THE GRAPH
  if (presence=="Copies"){
    metric_df$NCopies=metric_df$NCopies/sum(metric_df$NCopies)*100
    metric_plot=ggplot(metric_df, aes(NCopies, WinrateAverage*100))
    avg_presence=mean(metric_df$NCopies)
    std_presence=sd(metric_df$NCopies)
  }else if (presence=="Players"){
    metric_df$NPlayers=metric_df$NPlayers/sum(metric_df$NPlayers)*100
    metric_plot=ggplot(metric_df, aes(NPlayers, WinrateAverage*100))
    avg_presence=mean(metric_df$NPlayers)
    std_presence=sd(metric_df$NPlayers)
  }else if (presence=="Matches"){
    metric_df$TotalMatches=metric_df$TotalMatches/
      sum(metric_df$TotalMatches)*100
    metric_plot=ggplot(metric_df, aes(TotalMatches, WinrateAverage*100))
    avg_presence=mean(metric_df$TotalMatches)
    std_presence=sd(metric_df$TotalMatches)
  }
  
  if (diameters=="Copies"){
    metric_plot=metric_plot + 
      geom_point(aes(color = Archetype), size=metric_df$NCopies*diam_ratio,
                 show.legend = FALSE)
  }else if (diameters=="Players"){
    metric_plot=metric_plot + 
      geom_point(aes(color = Archetype), size=metric_df$NPlayers*diam_ratio,
                 show.legend = FALSE)
  }else if (diameters=="Matches"){
    metric_plot=metric_plot + 
      geom_point(aes(color = Archetype), size=metric_df$TotalMatches*
                   diam_ratio,show.legend = FALSE)
  }
  
  metric_plot=metric_plot + coord_cartesian() + theme_bw() + 
    labs(x=x_label, y=y_label, title=graph_title, subtitle=graph_subtitle) + 
    geom_text_repel(aes(label=Archetype),hjust=0, vjust=0,point.padding = NA,
                    size = 2, nudge_x = 0.1, direction = "y",
                    segment.size=0.2,segment.color="dark grey",segment.alpha=0.8) 
  
  #tiers CAN BE EITHER "Win+Pres","Pres M+SD" or "Pres %"
  if (tiers=="Win+Pres"){
    #TIERS BASED ON COMBINATION OF MEAN AND STANDARD DEVIATION OF PRESENCE AND WINRATE
    metric_plot=metric_plot + geom_abline(intercept = average, slope = coeffdir,
                                          color="red", size=1.5) +
      geom_abline(intercept = average+1*sdeviation, slope = coeffdir,
                  color="red", linetype="dotted", size=1.5) +
      geom_abline(intercept = average+2*sdeviation, slope = coeffdir,
                  color="red", linetype="dotted", size=1.5) +
      geom_abline(intercept = average+3*sdeviation, slope = coeffdir,
                  color="red", linetype="dashed", size=1.5) +
      geom_abline(intercept = average-1*sdeviation, slope = coeffdir,
                  color="red", linetype="dotted", size=1.5) +
      geom_abline(intercept = average-2*sdeviation, slope = coeffdir,
                  color="red", linetype="dotted", size=1.5) +
      geom_abline(intercept = average-3*sdeviation, slope = coeffdir,
                  color="red", linetype="dashed", size=1.5)
    
  }else if (tiers=="Pres M+SD"){
    #TIERS BASED ON MEAN + N * STANDARD DEVIATION OF PRESENCE, N={0,1,2,3}
    metric_plot=metric_plot + geom_vline(xintercept = avg_presence, linetype="dotted",
                                         color = "purple", size=0.5) +
      geom_text(aes(x=avg_presence, label="Tiers 2.5\n", y=
                      max(WinrateAverage*100)*0.99), colour="purple",
                angle=0, size=3) +
      geom_text(aes(x=avg_presence, label="\nPresence mean", y=
                      max(WinrateAverage*100)*0.99), colour="grey",
                angle=0, size=2) +
      geom_vline(xintercept = avg_presence + std_presence, linetype="dotted",
                 color = "blue", size=0.5) +
      geom_text(aes(x=avg_presence + std_presence, label="Tiers 2\n",
                    y=max(WinrateAverage*100)*0.98), colour="blue",
                angle=0, size=3) +
      geom_text(aes(x=avg_presence + std_presence, label="\nMean + 1*sd",
                    y=max(WinrateAverage*100)*0.98), colour="grey",
                angle=0, size=2) +
      geom_vline(xintercept = avg_presence + 2*std_presence, linetype="dotted",
                 color = "dark green", size=0.5) +
      geom_text(aes(x=avg_presence + 2*std_presence, label="Tiers 1.5\n",
                    y=max(WinrateAverage*100)*0.97), colour="dark green",
                angle=0, size=3) +
      geom_text(aes(x=avg_presence + 2*std_presence, label="\nMean + 2*sd",
                    y=max(WinrateAverage*100)*0.97), colour="grey",
                angle=0, size=2) +
      geom_vline(xintercept = avg_presence + 3*std_presence, linetype="dotted",
                 color = "orange", size=0.5) +
      geom_text(aes(x=avg_presence + 3*std_presence, label="Tiers 1\n",
                    y=max(WinrateAverage*100)*0.96), colour="orange",
                angle=0, size=3) +
      geom_text(aes(x=avg_presence + 3*std_presence, label="\nMean + 3*sd",
                    y=max(WinrateAverage*100)*0.96), colour="grey",
                angle=0, size=2) +
      geom_vline(xintercept = avg_presence + 4*std_presence, linetype="dotted",
                 color = "red", size=0.5) +
      geom_text(aes(x=avg_presence + 4*std_presence, label="Tiers 0\n",
                    y=max(WinrateAverage*100)*0.95), colour="red",
                angle=0, size=3) +
      geom_text(aes(x=avg_presence + 4*std_presence, label="\nMean + 4*sd",
                    y=max(WinrateAverage*100)*0.95), colour="grey",
                angle=0, size=2)
    
  }else if (tiers=="Pres %"){
    #TIERS BASED ON ARBITRARY % OF PRESENCE: 2,4,6,8,10
    metric_plot=metric_plot + geom_vline(xintercept = 10, linetype="dashed",
                                         color = "blue", size=2) +
      geom_vline(xintercept = 8, linetype="dotted",
                 color = "blue", size=1.5) +
      geom_vline(xintercept = 6, linetype="dotted",
                 color = "blue", size=1.5) +
      geom_vline(xintercept = 4, linetype="dotted",
                 color = "blue", size=1.5) +
      geom_vline(xintercept = 2, linetype="dashed",
                 color = "blue", size=2) +
      geom_abline(intercept = average, slope = 0,
                  color="red", linetype="dashed", size=1.5) +
      geom_abline(intercept = average+sdeviation, slope = 0,
                  color="red", linetype="dashed", size=1.5) +
      geom_abline(intercept = average-sdeviation, slope = 0,
                  color="red", linetype="dashed", size=1.5) +
      geom_abline(intercept = average+0.5*sdeviation, slope = 0,
                  color="red", linetype="dotted", size=1.5) +
      geom_abline(intercept = average-0.5*sdeviation, slope = 0,
                  color="red", linetype="dotted", size=1.5)
  }
  
  if (isLog){
    metric_plot=metric_plot + scale_x_continuous(trans = 'log10')
  }
  
  return(metric_plot)
  
}

#COMBINES THE RATIOS OF POINTS PER ROUND AND NUMBER OF COPIES FOR EACH
#ARCHETYPE, THEN PROVIDES A RANK BASED ON THAT
#THE NEW METRIC OBTAINED THAT WAY IS NORMALIZED TO BE BETWEEN 0 AND 1
#ALSO IMPLEMENTS THE VS META SCORE 
#https://www.vicioussyndicate.com/vs-meta-score-new-metric-measuring-archetypes-standing-meta/
archetypes_ranking = function(metric_df,beginning,end){
  
  beginning=as.Date(beginning,format="%Y-%m-%d", origin ="1970-01-01")
  end=as.Date(end,format="%Y-%m-%d", origin ="1970-01-01")
  
  #Make the values of both metrics start at 0 by substracting the minimum value
  metric_df_start_at_0=metric_df
  metric_df_start_at_0$TotalMatches = 
    metric_df_start_at_0$TotalMatches - min(metric_df_start_at_0$TotalMatches)
  metric_df_start_at_0$WinrateAverage = 
    metric_df_start_at_0$WinrateAverage - min(metric_df_start_at_0$WinrateAverage)
  
  #Make the values of both metrics go up to 1 by dividing by the maximum value
  metric_df_between_0_and_1 = metric_df_start_at_0
  metric_df_between_0_and_1$TotalMatches = 
    metric_df_between_0_and_1$TotalMatches / max(metric_df_between_0_and_1$TotalMatches)
  metric_df_between_0_and_1$WinrateAverage = 
    metric_df_between_0_and_1$WinrateAverage / max(metric_df_between_0_and_1$WinrateAverage)
  
  #We now have normalized metrics we can sum
  metric_df_normalized=metric_df_between_0_and_1
  metric_df_normalized$NormalizedSum = 
    Presence_Weight * metric_df_normalized$TotalMatches +
    PPR_Weight * metric_df_normalized$WinrateAverage
  
  #Also divide by the weights of each metric, so that even if we have a deck 
  #with the maximum value for each metric, i.e. 1 after normalization, 
  #we also find 1 as the value for the mark granted to the deck by the sum
  metric_df_normalized$NormalizedSum = 
    metric_df_normalized$NormalizedSum / (Presence_Weight+PPR_Weight)
  
  #Re-affect those new values to the original dataframe
  metric_df$NormalizedPresence=metric_df_normalized$TotalMatches
  metric_df$NormalizedWinrate=metric_df_normalized$WinrateAverage
  metric_df$NormalizedSum=metric_df_normalized$NormalizedSum
  
  metric_df = metric_df[order(-metric_df$NormalizedSum),]
  
  metric_df$RANK=(1:nrow(metric_df))
  
  metric_df$VSMetaScore=metric_df$NormalizedSum
  MetaPeak=c(max(metric_df$TotalMatches) - min(metric_df$TotalMatches) /
               max(metric_df$TotalMatches),
             max(metric_df$WinrateAverage) - min(metric_df$WinrateAverage) /
               max(metric_df$WinrateAverage))
  
  for (i in 1:length(metric_df$VSMetaScore)){
    ArchCoord=c((metric_df$TotalMatches[i]-min(metric_df$TotalMatches)) /
                  max(metric_df$TotalMatches),
                (metric_df$WinrateAverage[i]-min(metric_df$WinrateAverage)) /
                  max(metric_df$WinrateAverage))
    
    metric_df$VSMetaScore[i]=pointDistance(MetaPeak, ArchCoord, lonlat=FALSE)
  }
  return(metric_df)
}

#PLOT OF THE AVERAGE WINRATE FOR THE MOST POPULAR ARCHETYPES
#presence CAN BE EITHER "Copies", "Players" or "Matches"
winrates_graph = function(df,arch_ranked,presence,beginning,end,EventType){
  
  #GET ONLY THE DECKS APPEARING THE MOST IN THE DATA
  if (presence=="Copies"){
    #KEEP ONLY THE DECK WITH THE MOST COPIES
    presence_min=HistShare/100*length(df$Archetype$Archetype)
    arch_most_played=arch_ranked[arch_ranked$NCopies>=presence_min,]
  }else if (presence=="Players"){
    #KEEP ONLY THE DECK WITH THE MOST PLAYERS
    presence_min=HistShare/100*length(unique(df$Player))
    arch_most_played=arch_ranked[arch_ranked$NPlayers>=presence_min,]
  }else if (presence=="Matches"){
    #KEEP ONLY THE DECK WITH THE MOST MATCHES
    presence_min=HistShare/100*(sum(df$NRounds)+sum(df$T8Matches))
    arch_most_played=arch_ranked[arch_ranked$TotalMatches>=presence_min,]
  }
  
  #REORDER ARCHETYPES BY ASCENDING AVERAGE WINRATE
  arch_most_played$Archetype = reorder(arch_most_played$Archetype, 
                                        as.numeric(arch_most_played$WinrateAverage))
  #PLOT THE AVERAGE WINRATE AND THE CONFIDENCE INTERVALS
  y_label_winrate="Winrates of the most popular archetypes (%)"
  graph_title_winrate=paste(
    "Confidence intervals on the winrates of the most present archetypes ", 
    "( at least ",HistShare,"% of the ",presence,") between ", beginning, 
    " and ", end, " in MTGO ", EventType,sep="")
  
  ggplot(arch_most_played, aes(x=Archetype, y=WinrateAverage*100)) + 
    theme_classic() + geom_point(size=2,color="blue") +  
    geom_text_repel(aes(label=format(round(WinrateAverage*100,1), nsmall = 1)),
                    hjust=-0.3, vjust=-0.3,point.padding = NA)+ 
    labs(x=NULL, y=y_label_winrate, title=graph_title_winrate,
         subtitle="Red lines for the average of the bounds of the CI
Green line for the average of the computed winrate
by Anaël Yahi")+
    geom_errorbar(aes(ymax = Winrate95Max*100, ymin = Winrate95Min*100)) + 
    geom_hline(yintercept = mean(arch_most_played$WinrateAverage*100), 
               color="green", linetype="dashed", size=1)+ 
    geom_hline(yintercept = mean(arch_most_played$Winrate95Min*100), 
               color="red", linetype="dashed", size=0.5)+ 
    geom_hline(yintercept = mean(arch_most_played$Winrate95Max*100), 
               color="red", linetype="dashed", size=0.5) + 
    theme(axis.text.x  = element_text(size=12)) +
    scale_x_discrete(guide = guide_axis(n.dodge=2))
}

#PLOT THE REPARTITION FOR THE META SCORE OF THE PRESENCE AND WINRATES
#FOR THE MOST POPULAR ARCHETYPES
#PRESENCE: NUMBER OF MATCHES
meta_score_graph = function(df,arch_ranked,beginning,end,EventType){
  
  presence_min=HistShare/100*(sum(df$NRounds)+sum(df$T8Matches))
  arch_ranked_sub_2=arch_ranked[arch_ranked$TotalMatches>=log(presence_min),]
  
  meanData=mean(arch_ranked_sub_2$VSMetaScore)
  sdData=sd(arch_ranked_sub_2$VSMetaScore)
  meanPlusSd=meanData+sdData
  meanMinusSd=meanData-sdData
  
  arch_ranked_sub_2$Archetype=reorder(arch_ranked_sub_2$Archetype,
                                       arch_ranked_sub_2$VSMetaScore)
  
  titleLinearComb=paste("VS Meta Score for the most popular archetypes
At least ",HistShare,"% of presence
Presence Weight = ",Presence_Weight, " / Winrate weight = ",PPR_Weight, "
Between ",beginning," and ",end," in MTGO ",EventType,sep="")
  
  ggplot(arch_ranked_sub_2, aes(x=Archetype, y=VSMetaScore)) + 
    theme_classic() + geom_point(size=2,color="blue") +  
    geom_text_repel(aes(label=format(round(VSMetaScore,2), nsmall = 2)),
                    hjust=-0.3, vjust=-0.3,point.padding = NA)+ 
    labs(x=NULL, y="Value of the meta score metric", title=titleLinearComb,
         subtitle="Green line for the average of the meta score
Red lines for the average +/- a standard deviation
by Anaël Yahi")+
    geom_hline(yintercept = meanData, color="green", linetype="dashed", size=0.5)+ 
    geom_hline(yintercept = meanPlusSd, color="red", linetype="dashed", size=0.5)+ 
    geom_hline(yintercept = meanMinusSd, color="red", linetype="dashed", size=0.5) + 
    theme(axis.text.x  = element_text(size=12)) +
    scale_x_discrete(guide = guide_axis(n.dodge=2))
  
}

#PLOT THE REPARTITION FOR THE LINEAR COMBINATION OF THE PRESENCE AND WINRATES
#FOR THE MOST POPULAR ARCHETYPES
#PRESENCE: NUMBER OF MATCHES
linear_comb_graph = function(df,arch_ranked,beginning,end,EventType){
  
  presence_min=HistShare/100*(sum(df$NRounds)+sum(df$T8Matches))
  arch_ranked_sub_2=arch_ranked[arch_ranked$TotalMatches>=presence_min,]
  
  meanData=mean(arch_ranked_sub_2$NormalizedSum*100)
  sdData=sd(arch_ranked_sub_2$NormalizedSum*100)
  meanPlusSd=meanData+sdData
  meanMinusSd=meanData-sdData
  
  arch_ranked_sub_2$Archetype=reorder(arch_ranked_sub_2$Archetype,
                                       arch_ranked_sub_2$NormalizedSum)
  
  titleLinearComb=paste("Linear combination of the metrics for the most popular archetypes
At least ",HistShare,"% of presence
Presence Weight = ",Presence_Weight, " / Winrate weight = ",PPR_Weight, "
Between ",beginning," and ",end," in MTGO ",EventType,sep="")
  
  ggplot(arch_ranked_sub_2, aes(x=Archetype, y=NormalizedSum*100)) + 
    theme_classic() + geom_point(size=2,color="blue") +  
    geom_text_repel(aes(label=format(round(NormalizedSum*100,1), nsmall = 1)),
                    hjust=-0.3, vjust=-0.3,point.padding = NA)+ 
    labs(x=NULL, y="Value of the linear combination metric", title=titleLinearComb,
         subtitle="Green line for the average of the metrics linear combination
Red lines for the average +/- a standard deviation
by Anaël Yahi")+
    geom_hline(yintercept = meanData, color="green", linetype="dashed", size=0.5)+ 
    geom_hline(yintercept = meanPlusSd, color="red", linetype="dashed", size=0.5)+ 
    geom_hline(yintercept = meanMinusSd, color="red", linetype="dashed", size=0.5) + 
    theme(axis.text.x  = element_text(size=12)) +
    scale_x_discrete(guide = guide_axis(n.dodge=2))
  
}

#PLOT THE REPARTITION FOR THE A LOGARITHMIC COMBINATION OF THE PRESENCE AND 
#WINRATES FOR THE MOST POPULAR ARCHETYPES
#PRESENCE: NUMBER OF MATCHES
log_comb_graph = function(df,arch_ranked,beginning,end,EventType){
  
  presence_min=HistShare/100*(sum(df$NRounds)+sum(df$T8Matches))
  arch_ranked_sub_2=arch_ranked[arch_ranked$TotalMatches>=log(presence_min),]
  
  meanData=mean(arch_ranked_sub_2$NormalizedSum*100)
  sdData=sd(arch_ranked_sub_2$NormalizedSum*100)
  meanPlusSd=meanData+sdData
  meanMinusSd=meanData-sdData
  
  arch_ranked_sub_2$Archetype=reorder(arch_ranked_sub_2$Archetype,
                                      arch_ranked_sub_2$NormalizedSum)
  
  titleLinearComb=paste("Combination of the metrics for the most popular archetypes
Above the average presence - Linear winrate, logarithmic presence
Presence Weight = ",Presence_Weight, " / Winrate weight = ",PPR_Weight,  "
Between ",beginning," and ",end," in MTGO ",EventType,sep="")
  
  ggplot(arch_ranked_sub_2, aes(x=Archetype, y=NormalizedSum*100)) + 
    theme_classic() + 
    geom_point(aes(size=10),show.legend = FALSE,color="blue") +  
    geom_text_repel(aes(label=format(round(NormalizedSum*100,1), nsmall = 1)),
                    hjust=1, vjust=1.2,point.padding = NA,color="dark grey",
                    size = 4, nudge_x = 0.1, direction = "y", show.legend = FALSE)+ 
    labs(x=NULL, y="Value of the linear combination metric", title=titleLinearComb,
         subtitle="by Anaël Yahi") +
    
    geom_hline(yintercept = meanData-3*sdData, color="#004CA3", linetype="dashed", size=1) +
    geom_text(aes(x=0, y=meanData-3*sdData,label="Tier 3\n"), colour="#004CA3",angle=0, size=5) +
    geom_text(aes(x=0, y=meanData-3*sdData-0.5,label="Mean - 3*SD"), colour="grey",angle=0, size=4) + 
    
    geom_hline(yintercept = meanData-2*sdData, color="#8A51A5", linetype="dashed", size=1) +
    geom_text(aes(x=0, y=meanData-2*sdData,label="Tier 2.5\n"), colour="#8A51A5",angle=0, size=5) + 
    geom_text(aes(x=0, y=meanData-2*sdData-0.5,label="Mean - 2*SD"), colour="grey",angle=0, size=4) +
    
    geom_hline(yintercept = meanData-sdData, color="#CB5E99", linetype="dashed", size=1) +
    geom_text(aes(x=0, y=meanData-sdData,label="Tier 2\n"), colour="#CB5E99",angle=0, size=5) +
    geom_text(aes(x=0, y=meanData-sdData-0.5,label="Mean - SD"), colour="grey",angle=0, size=4) +
    
    geom_hline(yintercept = meanData, color="#F47B89", linetype="dashed", size=1)+
    geom_text(aes(x=0, y=meanData,label="Tier 1.5\n"), colour="#F47B89",angle=0, size=5) +
    geom_text(aes(x=0, y=meanData-0.5,label="Mean"), colour="grey",angle=0, size=4) +
    
    geom_hline(yintercept = meanData+sdData, color="#FFA47E", linetype="dashed", size=1)+ 
    geom_text(aes(x=0, y=meanData+sdData,label="Tier 1\n"), colour="#FFA47E",angle=0, size=5) +
    geom_text(aes(x=0, y=meanData+sdData-0.5,label="Mean + SD"), colour="grey",angle=0, size=4) +
    
    geom_hline(yintercept = meanData+2*sdData, color="#FFD286", linetype="dashed", size=1)+ 
    geom_text(aes(x=0, y=meanData+2*sdData,label="Tier 0.5\n"), colour="#FFD286",angle=0, size=5) +
    geom_text(aes(x=0, y=meanData+2*sdData-0.5,label="Mean + 2*SD"), colour="grey",angle=0, size=4) +
    
    geom_hline(yintercept = meanData+3*sdData, color="green", linetype="dashed", size=1)+ 
    geom_text(aes(x=0, y=meanData+3*sdData,label="Tier 0\n"), colour="green",angle=0, size=5) +
    geom_text(aes(x=0, y=meanData+3*sdData-0.5,label="Mean + 3*SD"), colour="grey",angle=0, size=4) +
    
    theme_bw() + scale_x_discrete(guide = guide_axis(n.dodge=2), expand = c(0.15, 0))
  
}

#PLOT THE REPARTITION FOR THE LINEAR COMBINATION OF THE PRESENCE AND WINRATES
#FOR THE MOST POPULAR ARCHETYPES
#PRESENCE: NUMBER OF MATCHES
lower_bound_ci_winrate_graph = function(df,arch_ranked,beginning,end,EventType){
  
  presence_min=HistShare/100*(sum(df$NRounds)+sum(df$T8Matches))
  arch_ranked_sub_2=arch_ranked[arch_ranked$TotalMatches>=presence_min,]
  
  meanData=mean(arch_ranked_sub_2$Winrate95Min*100)
  sdData=sd(arch_ranked_sub_2$Winrate95Min*100)
  meanPlusSd=meanData+sdData
  meanMinusSd=meanData-sdData
  
  arch_ranked_sub_2$Archetype=reorder(arch_ranked_sub_2$Archetype,
                                       arch_ranked_sub_2$Winrate95Min)
  
  titleLinearComb=paste("Lower bound of the confidence intervals for the winrates of the most popular decks
At least ",HistShare,"% of presence
Presence Weight = ",Presence_Weight, " / Winrate weight = ",PPR_Weight,   "
Between ",beginning," and ",end," in MTGO ",EventType,sep="")
  
  ggplot(arch_ranked_sub_2, aes(x=Archetype, y=Winrate95Min*100)) + 
    theme_classic() + geom_point(size=2,color="blue") +  
    geom_text_repel(aes(label=format(round(Winrate95Min*100,1), nsmall = 1)),
                    hjust=-0.3, vjust=-0.3,point.padding = NA)+ 
    labs(x=NULL, y="Lower estimation of the winrate (%)", title=titleLinearComb,
         subtitle="Green line for the average of the lower estimation of winrates
Red lines for the average +/- a standard deviation
by Anaël Yahi")+
    geom_hline(yintercept = meanData, color="green", linetype="dashed", size=1)+ 
    geom_hline(yintercept = meanPlusSd, color="red", linetype="dashed", size=0.5)+ 
    geom_hline(yintercept = meanMinusSd, color="red", linetype="dashed", size=0.5) + 
    theme(axis.text.x  = element_text(size=12)) +
    scale_x_discrete(guide = guide_axis(n.dodge=2))
}

#PLOT THE REPARTITION FOR THE WINRATE RATIO OF ARCHETYPE OUT OF PLAYERS
#FOR THE MOST POPULAR ARCHETYPES
#PRESENCE: NUMBER OF MATCHES
winrate_ratio_arch_out_player_graph = function(df,metric_df,beginning,end,
                                               EventType){
  
  presence_min=HistShare/100*(sum(df$NRounds)+sum(df$T8Matches))
  metric_df_2=metric_df[metric_df$TotalMatches>=presence_min,]
  
  metric_df_2$Archetype=reorder(metric_df_2$Archetype,
                                 metric_df_2$WinrateArchetypeOutPlayers)
  
  titleRatioWin=paste("Ratio of the winrate of the archetypes out of the winrate ", 
                      "of their pilotes for the most popular decks
At least ",HistShare,"% of presence",
                      "\nBetween ",beginning," and ",end," in MTGO ",EventType,sep="")
  
  ggplot(metric_df_2, aes(x=Archetype, y=WinrateArchetypeOutPlayers)) + 
    theme_classic() + geom_point(size=2,color="blue") +  
    geom_text_repel(aes(label=format(round(WinrateArchetypeOutPlayers,3), nsmall = 3)),
                    hjust=-0.3, vjust=-0.3,point.padding = NA)+ 
    labs(x=NULL, y="Ratio", title=titleRatioWin,
         subtitle="Ratio>1 means that the archetype winrate is over its pilots' winrate
         \nby Anaël Yahi")+
    geom_hline(yintercept = 1, color="green", linetype="dotted", size=1)+
    theme(axis.text.x  = element_text(size=12)) +
    scale_x_discrete(guide = guide_axis(n.dodge=2))
}

#SORT THE ARCHETYPES IN CLUSTERS BASED ON PRESENCE AND WINRATE
kmeans_arch = function (metric_df,k,iter,init,algo,beginning,end,
                        count_wr,only_best,EventType){
  df_elim=select(metric_df, TotalMatches, WinrateAverage, Archetype, NPlayers)
  if(only_best){
    df_elim=df_elim[df_elim$TotalMatches>mean(df_elim$TotalMatches),]
  }
  df_elim$Presence=df_elim$TotalMatches/(sum(df_elim$TotalMatches))*100
  if (count_wr){
    df_kde=select(df_elim, Presence, WinrateAverage)
  }else{
    df_kde=select(df_elim, Presence)
  }
  
  set.seed(123)
  res.km=kmeans(scale(df_kde), k, iter.max = iter, nstart = init, 
                algorithm = algo)
  df_kde$CLUSTER=factor(res.km$cluster)
  df_kde$Archetype=df_elim$Archetype
  df_kde$NPlayers=df_elim$NPlayers
  df_kde$WinrateAverage=df_elim$WinrateAverage
  
  x_label="Presence"
  y_label="Winrate"
  graph_title=paste("Winrates depending on presence:", Classification,"archetypes ", 
                    "between", beginning, "and", end, "in MTGO", EventType,sep = " ")
  graph_subtitle=paste("Clustered in",k,"categories with",algo,"algorithm
by Anaël Yahi",sep = " ")
  ggplot(data = df_kde,  mapping = aes(x = Presence, y = WinrateAverage, 
                                       colour = CLUSTER)) + 
    coord_cartesian() + theme_bw() + scale_x_continuous(trans = 'log10') + 
    labs(x=x_label, y=y_label, title=graph_title, subtitle=graph_subtitle) +
    geom_text_repel(aes(label=Archetype),hjust=-1.5, vjust=-0.5,point.padding = NA) + 
    geom_point(aes(size=NPlayers),show.legend = FALSE)
}

#GENERATE A DF CONTAINING TIERS LISTS DEPENDING ON VARIOUS METRICS
generate_tiers_lists = function(arch_ranked){
  #TIERS LIST BASED ON METRIC SCORE
  arch_metric_score=arch_ranked[c("Archetype","NormalizedSum")]
  arch_metric_score=arrange(arch_metric_score,desc(NormalizedSum))
  head(arch_metric_score)
  mmc=mean(arch_metric_score$NormalizedSum)
  sdmc=sd(arch_metric_score$NormalizedSum)
  arch_metric_score_tiers1=arch_metric_score[arch_metric_score$NormalizedSum>mmc+sdmc,]
  arch_metric_score_tiers1.5=arch_metric_score[arch_metric_score$NormalizedSum>mmc &
                                                 arch_metric_score$NormalizedSum<=mmc+sdmc,]
  arch_metric_score_tiers2=arch_metric_score[arch_metric_score$NormalizedSum<=mmc &
                                               arch_metric_score$NormalizedSum>=mmc-sdmc,]
  arch_metric_score_tiers2.5=arch_metric_score[arch_metric_score$NormalizedSum<mmc-sdmc,]
  # arch_metric_score_tiers1
  # arch_metric_score_tiers1.5
  # arch_metric_score_tiers2
  # arch_metric_score_tiers2.5
  
  #TIERS LIST BASED ON VS META SCORE
  arch_meta_score=arch_ranked[c("Archetype","VSMetaScore")]
  arch_meta_score=arrange(arch_meta_score,VSMetaScore)
  head(arch_meta_score)
  mms=mean(arch_meta_score$VSMetaScore)
  sdms=sd(arch_meta_score$VSMetaScore)
  arch_meta_score_tiers2.5=arch_meta_score[arch_meta_score$VSMetaScore>mms+sdms,]
  arch_meta_score_tiers2=arch_meta_score[arch_meta_score$VSMetaScore>mms &
                                           arch_meta_score$VSMetaScore<=mms+sdms,]
  arch_meta_score_tiers1.5=arch_meta_score[arch_meta_score$VSMetaScore<=mms &
                                             arch_meta_score$VSMetaScore>=mms-sdms,]
  arch_meta_score_tiers1=arch_meta_score[arch_meta_score$VSMetaScore<mms-sdms,]
  # arch_meta_score_tiers1
  # arch_meta_score_tiers1.5
  # arch_meta_score_tiers2
  # arch_meta_score_tiers2.5
  
  #TIERS LIST BASED ON PRESENCE
  arch_presence_score=arch_ranked[c("Archetype","TotalMatches")]
  arch_presence_score=arrange(arch_presence_score,desc(TotalMatches))
  head(arch_presence_score)
  mps=mean(arch_presence_score$TotalMatches)
  sdps=sd(arch_presence_score$TotalMatches)
  arch_presence_score_tiers1=arch_presence_score[arch_presence_score$TotalMatches>mps+sdps,]
  arch_presence_score_tiers1.5=arch_presence_score[arch_presence_score$TotalMatches>mps &
                                                     arch_presence_score$TotalMatches<=mps+sdps,]
  arch_presence_score_tiers2=arch_presence_score[arch_presence_score$TotalMatches<=mps &
                                                   arch_presence_score$TotalMatches>=mps-sdps,]
  arch_presence_score_tiers2.5=arch_presence_score[arch_presence_score$TotalMatches<mps-sdps,]
  # arch_presence_score_tiers1
  # arch_presence_score_tiers1.5
  # arch_presence_score_tiers2
  # arch_presence_score_tiers2.5
  
  #TIERS LIST BASED ON AVERAGE WINRATE
  arch_winrate_score=arch_ranked[c("Archetype","WinrateAverage")]
  arch_winrate_score=arrange(arch_winrate_score,desc(WinrateAverage))
  head(arch_winrate_score)
  mws=mean(arch_winrate_score$WinrateAverage)
  sdws=sd(arch_winrate_score$WinrateAverage)
  arch_winrate_score_tiers1=arch_winrate_score[arch_winrate_score$WinrateAverage>mws+sdws,]
  arch_winrate_score_tiers1.5=arch_winrate_score[arch_winrate_score$WinrateAverage>mws &
                                                   arch_winrate_score$WinrateAverage<=mws+sdws,]
  arch_winrate_score_tiers2=arch_winrate_score[arch_winrate_score$WinrateAverage<=mws &
                                                 arch_winrate_score$WinrateAverage>=mws-sdws,]
  arch_winrate_score_tiers2.5=arch_winrate_score[arch_winrate_score$WinrateAverage<mws-sdws,]
  # arch_winrate_score_tiers1
  # arch_winrate_score_tiers1.5
  # arch_winrate_score_tiers2
  # arch_winrate_score_tiers2.5
  
  #TIERS LIST BASED ON LOWER ESTIMATION OF WINRATE
  arch_low_winrate_score=arch_ranked[c("Archetype","Winrate95Min")]
  arch_low_winrate_score=arrange(arch_low_winrate_score,desc(Winrate95Min))
  head(arch_low_winrate_score)
  mlws=mean(arch_low_winrate_score$Winrate95Min)
  sdlws=sd(arch_low_winrate_score$Winrate95Min)
  arch_low_winrate_score_tiers1=arch_low_winrate_score[arch_low_winrate_score$Winrate95Min>mlws+sdlws,]
  arch_low_winrate_score_tiers1.5=arch_low_winrate_score[arch_low_winrate_score$Winrate95Min>mlws &
                                                           arch_low_winrate_score$Winrate95Min<=mlws+sdlws,]
  arch_low_winrate_score_tiers2=arch_low_winrate_score[arch_low_winrate_score$Winrate95Min<=mlws &
                                                         arch_low_winrate_score$Winrate95Min>=mlws-sdlws,]
  arch_low_winrate_score_tiers2.5=arch_low_winrate_score[arch_low_winrate_score$Winrate95Min<mlws-sdlws,]
  # arch_low_winrate_score_tiers1
  # arch_low_winrate_score_tiers1.5
  # arch_low_winrate_score_tiers2
  # arch_low_winrate_score_tiers2.5
  
  #EXPORT ALL THE TIERS LISTS TO CSV
  low_winrate_score_tiers_list=list(paste(arch_low_winrate_score_tiers1$Archetype,collapse=" - "),
                                    paste(arch_low_winrate_score_tiers1.5$Archetype,collapse=" - "),
                                    paste(arch_low_winrate_score_tiers2$Archetype,collapse=" - "),
                                    paste(arch_low_winrate_score_tiers2.5$Archetype,collapse=" - "))
  winrate_score_tiers_list=list(paste(arch_winrate_score_tiers1$Archetype,collapse=" - "),
                                paste(arch_winrate_score_tiers1.5$Archetype,collapse=" - "),
                                paste(arch_winrate_score_tiers2$Archetype,collapse=" - "),
                                paste(arch_winrate_score_tiers2.5$Archetype,collapse=" - "))
  presence_score_tiers_list=list(paste(arch_presence_score_tiers1$Archetype,collapse=" - "),
                                 paste(arch_presence_score_tiers1.5$Archetype,collapse=" - "),
                                 paste(arch_presence_score_tiers2$Archetype,collapse=" - "),
                                 paste(arch_presence_score_tiers2.5$Archetype,collapse=" - "))
  meta_score_tiers_list=list(paste(arch_meta_score_tiers1$Archetype,collapse=" - "),
                             paste(arch_meta_score_tiers1.5$Archetype,collapse=" - "),
                             paste(arch_meta_score_tiers2$Archetype,collapse=" - "),
                             paste(arch_meta_score_tiers2.5$Archetype,collapse=" - "))
  metric_score_tiers_list=list(paste(arch_metric_score_tiers1$Archetype,collapse=" - "),
                               paste(arch_metric_score_tiers1.5$Archetype,collapse=" - "),
                               paste(arch_metric_score_tiers2$Archetype,collapse=" - "),
                               paste(arch_metric_score_tiers2.5$Archetype,collapse=" - "))
  
  df_tiers_list=data.frame(presence=I(presence_score_tiers_list),
                           winrate=I(winrate_score_tiers_list),
                           low_winrate=I(low_winrate_score_tiers_list),
                           comb_presence_winrate=I(metric_score_tiers_list),
                           meta_score=I(metric_score_tiers_list)
  )
  
  rownames(df_tiers_list)=c("Tiers 1","Tiers 1.5","Tiers 2","Tiers 2.5")
  
  return(df_tiers_list)
}

#COUNT THE NUMBER OF TOP8 FOR EACH PLAYER
players_top8 = function(df) {
  #Note: EronRelentless AND Kanonenfutter ARE THE SAME PERSON
  #REMOVES ALL THE PLAYERS WHOSE RESULT 
  dftop8=df[df$NumericResult <=8,]
  top8players=generate_player_list(dftop8)
  top8players$NAppearances=rep(1,length(top8players$Players))
  for (i in 1:length(top8players$NAppearances)){
    play_identification=which(dftop8$Player==top8players$Players[i])
    top8players_sub=dftop8[play_identification,]
    #NUMBER OF APPEARANCES IN THE DATA OF THE CORRESPONDING ARCHETYPE
    top8players$NAppearances[i]=length(play_identification)
    #LIST OF DIFFERENT ARCHETYPES THAT PLAYER PLAYED
    top8players$ArchetypeNames[i]=list(unique(top8players_sub$Archetype$
                                                Archetype))
    arch_count=c()
    for(j in 1:length(top8players$ArchetypeNames[[i]])){
      arch_count[j]=length(top8players_sub[
        top8players_sub$Archetype$Archetype==
          top8players$ArchetypeNames[[i]][[j]],]$AnchorUri)
    }
    top8players$ArchetypeCounts[i]=list(arch_count)
    
    top8players$URL[i]=list(unique(top8players_sub$AnchorUri))
  }
  top8players=arrange(top8players,desc(NAppearances))
  return(top8players)
}

#RETURN THE NUMBER OF WINS AND LOSSES IN A GIVEN MATCHUP
get_matchup_data = function(df,arch1,arch2){
  winsArch1VS2 = 0
  lossesArch1VS2 = 0
  dfArch1 = df[df$Archetype$Archetype==arch1,]
  conditionMUNotNull = !sapply(dfArch1$Matchups, function(x) length(x) == 0 )
  for (i in (1:nrow(dfArch1))[conditionMUNotNull]){
    matchesI = dfArch1[i,]$Matchups[[1]]
    matchesArch1VS2 = matchesI[matchesI$OpponentArchetype == arch2,]
    
    WinsI = matchesArch1VS2$Wins 
    DefeatsI = matchesArch1VS2$Losses 
    
    winsArch1VS2 = winsArch1VS2 + sum(WinsI > DefeatsI)
    lossesArch1VS2 = lossesArch1VS2 + sum(WinsI < DefeatsI) 
  }
  
  return(c(Wins = winsArch1VS2, Losses = lossesArch1VS2))
}

#COMPUTES A NAME FOR THE MATCHUP MATRIX
generate_mu_matrix_title = function(beginning,end,MTGFormat,EventType){
  MUMatrixTitle=paste("Win rate of Y (ordinates) against X (abscissa) in",MTGFormat,EventType,"events between", 
                       beginning, "and", end,sep = " ")
  return(MUMatrixTitle)
}

# RETURN THE MATCHUP MATRIX OF MOST PLAYED ARCHETYPES IN THE DATA
generate_matchup_matrix = function(df,PieShare,beginning,end,mtgFormat,eventType){
  df_gen = generate_metagame_data(df,PieShare,"Matches")
  
  archetypeList = df_gen$Archetype
  otherName = tail(archetypeList, n=1)
  
  win_matrix = matrix(0, ncol = nrow(df_gen), nrow = nrow(df_gen))
  rownames(win_matrix) = df_gen$Archetype
  colnames(win_matrix) = df_gen$Archetype
  
  loss_matrix = win_matrix
  match_matrix = win_matrix
  wr_matrix = win_matrix
  wr95Min_matrix = win_matrix
  wr95Max_matrix = win_matrix
  output_matrix = data.frame(win_matrix)
  
  conditionMUNotNull = !sapply(df$Matchups, function(x) length(x) == 0 )
  for (i in (1:nrow(df))[conditionMUNotNull]){
    
    archetype1I = df[i,]$Archetype$Archetype
    archetype1I = ifelse(archetype1I%in% archetypeList,archetype1I,otherName)
    matchesI = df[i,]$Matchups[[1]]
    
    for (j in 1:nrow(matchesI)){
      matchesIJ = matchesI[j,]
      archetype2IJ = matchesIJ$OpponentArchetype
      archetype2IJ = ifelse(archetype2IJ%in% archetypeList,archetype2IJ,otherName)
      
      if(matchesIJ$Wins > matchesIJ$Losses){
        win_matrix[archetype1I,archetype2IJ] = win_matrix[archetype1I,archetype2IJ] + 1
      }else if(matchesIJ$Wins < matchesIJ$Losses){
        loss_matrix[archetype1I,archetype2IJ] = loss_matrix[archetype1I,archetype2IJ] + 1
      }
    }
  }
  
  match_matrix = win_matrix + loss_matrix
  
  wr_matrix = round(win_matrix/match_matrix*100,digits = 1)
  
  for(i in 1:nrow(wr95Min_matrix)){
    for(j in 1:nrow(wr95Min_matrix)){
      wr95Min_matrix[i,j]=binom.test(win_matrix[i,j], match_matrix[i,j], 
                                     p=0.5,alternative="two.sided", 
                                     conf.level=0.95)$conf.int[1]
    }
  }
  wr95Min_matrix = round(wr95Min_matrix*100,digits = 1)
  
  for(i in 1:nrow(wr95Max_matrix)){
    for(j in 1:nrow(wr95Max_matrix)){
      wr95Max_matrix[i,j]=binom.test(win_matrix[i,j], match_matrix[i,j], 
                                     p=0.5,alternative="two.sided", 
                                     conf.level=0.95)$conf.int[2]
    }
  }
  wr95Max_matrix = round(wr95Max_matrix*100,digits = 1)
  
  for(i in 1:nrow(wr95Max_matrix)){
    for(j in 1:nrow(wr95Max_matrix)){
      output_matrix[i,j] = paste0(wr95Min_matrix[i,j],"% - ",
                                 wr95Max_matrix[i,j],"%\n",
                                 wr_matrix[i,j],"%\n",
                                 match_matrix[i,j]," matches")
      }
  }
  
  arch1Vec = rep(colnames(wr_matrix),each=nrow(wr_matrix)) 
  arch2Vec = rep(colnames(wr_matrix),nrow(wr_matrix)) 
  displayOrder = rep(1:nrow(wr_matrix),each=nrow(wr_matrix)) 
  share = rep(df_gen$Share,each=nrow(wr_matrix)) 
  winRateArch = rep(round(rowSums(win_matrix)/rowSums(match_matrix)*100,digit=1),each=nrow(wr_matrix)) 
  plotTableWR = data.frame(Archetype1 = arch1Vec, 
                           Archetype2 = arch2Vec,
                           MUWinrate = as.vector(t(wr_matrix)),
                           Wins = as.vector(t(win_matrix)),
                           Losses = as.vector(t(loss_matrix)),
                           Matches = as.vector(t(match_matrix)),
                           WR95Min = as.vector(t(wr95Min_matrix)),
                           WR95Max = as.vector(t(wr95Max_matrix)),
                           DisplayOrder = displayOrder,
                           Share = share, WinRateArch = winRateArch)
  plotTableWR$ArchShare1 = paste0("<span style = 'font-size:11pt'><b>",
                                  plotTableWR$Archetype1,"</b></span>",
                                  "<br>Share: ",plotTableWR$Share,
                                  " %<br>Win Rate: ",plotTableWR$WinRateArch,"%")
  
  plotTableWR$Archetype2 = factor(plotTableWR$Archetype2, 
                                 levels=unique(plotTableWR$Archetype2[order(plotTableWR$DisplayOrder)]), ordered=TRUE)
  
  # plotTableWR$OutputText = rep("Linebreaks<br>Linebreaks<br>Linebreaks",nrow(plotTableWR))
  plotTableWR$OutputText = paste0("<span style = 'font-size:8pt'>",
                                  plotTableWR$WR95Min,"% - ",plotTableWR$WR95Max,
                                  "%</span><br><b>",plotTableWR$MUWinrate,
                                  "%</b><br><span style = 'font-size:8pt'>",
                                  plotTableWR$Matches," matches</span>")
  
  muMatrixPlot = ggplot(plotTableWR,aes(x = Archetype2, 
                         y = reorder(ArchShare1,-DisplayOrder), 
                          col = MUWinrate, fill = MUWinrate, label = OutputText)) +
    geom_tile(color = "black",lwd = 0.5,linetype = 1) +
    theme(axis.text.x = element_text(face="bold",size=11),
          axis.text.y = element_markdown(),
          legend.position = "none",
          plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5)) + 
    scale_fill_gradientn(colours = paletteer_c("ggthemes::Red-Green-Gold Diverging", 30)) +
    scale_color_gradientn(colours = paletteer_c("ggthemes::Red-Green-Gold Diverging", 30)) +
    scale_x_discrete(position = "top") +
    labs(x=NULL, y=NULL, title=generate_mu_matrix_title(beginning,end,mtgFormat,eventType),
         subtitle="by Anaël Yahi")+
    geom_richtext( fill = NA, label.color = NA, # remove background and outline
                   label.padding = grid::unit(rep(0, 4), "pt"), # remove padding
                   color = "black") 
  
  muMatrixPlot
  
}


